---
title: "Introduction to datavisualisation"
teaching: 50
exercises: 30
questions:
- "What data types are available in R?"
- "What is an object?"
- "How can values be initially assigned to variables of different data types?"
- "What arithmetic and logical operators can be used?"
- "How can subsets be extracted from vectors?"
- "How does R treat missing values?"
- "How can we deal with missing values in R?"
objectives: 
- "Define the following terms as they relate to R: object, assign, call, function, arguments, options."
- "Assign values to objects in R."
- "Learn how to name objects."
- "Use comments to inform script."
- "Solve simple arithmetic operations in R."
- "Call functions and use arguments to change their default options."
- "Inspect the content of vectors and manipulate their content."
- "Subset and extract values from vectors."
- "Analyze vectors with missing data."
keypoints:
- "Access individual values by location using `[]`."
- "Access arbitrary sets of data using `[c(...)]`."
- "Use logical operations and logical vectors to access subsets of data."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("01-")
source("../bin/download_data.R")
```

Først og fremmest - hvem er din målgruppe, hvad er det du vil vise? Hvad er 
formålet med visualilseringen?


Herunder er der stadig en del kode og andet skrammel, der ikke er fjernet endnu.

## Why are we visualising data? ##
Udnytte vores hjerne til at se sammenhænge og mønstre i data - men husk at 
validere de mønstre, for vi er rigtig gode til at se mønstre der ikke er der

Vise andre sammenhænge og mønstre, så de kan forstå data. Der er både et 
eksplorativt element, hvor vi bruger visualiseringer til at opdage mønstre
og et kommunikativt element hvor vi bruger visualiseringer til at vise mønstre.
https://www.visualcapitalist.com/data-visualization-cholera/




```{r, purl=FALSE}
area_hectares <- 1.0
```

> ## Objects vs. variables
>
> What are known as `objects` in `R` are known as `variables` in many other
> programming languages. Depending on the context, `object` and `variable` can
> have drastically different meanings. However, in this lesson, the two words
> are used synonymously. For more information see:
> [https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects)
{: .callout}


```{r, purl=FALSE}
area_hectares <- 1.0    # doesn't print anything
(area_hectares <- 1.0)  # putting parenthesis around the call prints the value of `area_hectares`
area_hectares         # and so does typing the name of the object
```


```{r, purl=FALSE}
area_acres <- 2.47 * area_hectares
```



```{r, purl=FALSE}
area_hectares <- 50
```

> ## Exercise
> 
> What do you think is the current content of the object `area_acres`? 123.5 or
> 6.175?
>
> > ## Solution
> >
> > The value of `area_acres` is still 6.175 because you have not
> > re-run the line `area_acres <- 2.47 * area_hectares` since
> > changing the value of `area_hectares`.
> {: .solution}
{: .challenge}


```{r}
area_hectares <- 1.0			# land area in hectares
area_acres <- area_hectares * 2.47	# convert to acres
area_acres				# print land area in acres.
```



> ## Exercise
>
> Create two variables `r_length` and `r_width` and assign them values. It should be noted that, 
> because `length` is a built-in R function, R Studio might add "()" after you type `length` and 
> if you leave the parentheses you will get unexpected results. 
> This is why you might see other programmers abbreviate common words.
> Create a third variable `r_area` and give it a value based on the current values of `r_length` 
> and `r_width`.
> Show that changing the values of either `r_length` and `r_width` does not affect the value of 
> `r_area`.
> 
> > ## Solution
> > 
> > ```{r}
> > r_length <- 2.5
> > r_width <- 3.2
> > r_area <- r_length * r_width
> > r_area
> > # change the values of r_length and r_width
> > r_length <- 7.0
> > r_width <- 6.5
> > # the value of r_area isn't changed
> > r_area
> > ```
> > 
> {: .solution}
{: .challenge}



```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

> ## Exercise
>
> Type in `?round` at the console and then look at the output in the Help pane.
> What other functions exist that are similar to `round`?
> How do you use the `digits` parameter in the round function?
{: .challenge}

## Vectors and data types

```{r, echo=FALSE, purl=TRUE}
### Vectors and data types
```

```{r, purl=FALSE}
hh_members <- c(3, 7, 10, 6)
hh_members
```

```{r, purl=FALSE}
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type
```

```{r, purl=FALSE}
length(hh_members)
length(respondent_wall_type)
```


```{r, purl=FALSE}
class(hh_members)
class(respondent_wall_type)
```


```{r, purl=FALSE}
str(hh_members)
str(respondent_wall_type)
```

You can use the `c()` function to add other elements to your vector:
```{r, purl=FALSE}
possessions <- c("bicycle", "radio", "television")
possessions <- c(possessions, "mobile_phone") # add to the end of the vector
possessions <- c("car", possessions) # add to the beginning of the vector
possessions
```



> ## Exercise
>
>
> We’ve seen that atomic vectors can be of type character, numeric (or double),
>   integer, and logical. But what happens if we try to mix these types in a
>   single vector?
>
> > ## Solution
> >
> > R implicitly converts them to all be the same type.
> {: .solution}
>
> What will happen in each of these examples? (hint: use `class()`
> to check the data type of your objects):
>
>  ```{r, results="hide"}
>  num_char <- c(1, 2, 3, "a")
>  num_logical <- c(1, 2, 3, TRUE)
>  char_logical <- c("a", "b", "c", TRUE)
>  tricky <- c(1, 2, 3, "4")
>  ```
>
>
> Why do you think it happens?
>
> > ## Solution
> >
> >  Vectors can be of only one data type. R tries to
> > convert (coerce) the content of this vector to find a "common
> > denominator" that doesn't lose any information.
> {: .solution}
>
>
> How many values in `combined_logical` are `"TRUE"` (as a character) in the
> following example:
>
> ```{r, results="hide"}
> num_logical <- c(1, 2, 3, TRUE)
> char_logical <- c("a", "b", "c", TRUE)
> combined_logical <- c(num_logical, char_logical)
>  ```
> &nbsp;
>
> > ## Solution
> >
> > Only one. There is no memory of past data types, and the coercion
> > happens the
> > first time the vector is evaluated. Therefore, the `TRUE` in
> > `num_logical`
> > gets converted into a `1` before it gets converted into `"1"` in
> > `combined_logical`.
> {: .solution}
>
> You've probably noticed that objects of different types get
>   converted into a single, shared type within a vector. In R, we
>   call converting objects from one class into another class
>   _coercion_. These conversions happen according to a hierarchy,
>   whereby some types get preferentially coerced into other
>   types. Can you draw a diagram that represents the hierarchy of how
>   these data types are coerced?
>
{: .challenge}



```{r, results='show', purl=FALSE}
respondent_wall_type <- c("muddaub", "burntbricks", "sunbricks")
respondent_wall_type[2]
respondent_wall_type[c(3, 2)]
```

We can also repeat the indices to create an object with more elements than the
original one:

```{r, results='show', purl=FALSE}
more_respondent_wall_type <- respondent_wall_type[c(1, 2, 3, 2, 1, 3)]
more_respondent_wall_type
```


```{r, results='show', purl=FALSE}
hh_members <- c(3, 7, 10, 6)
hh_members[c(TRUE, FALSE, TRUE, TRUE)]
```

```{r, results='show', purl=FALSE}
hh_members > 5    # will return logicals with TRUE for the indices that meet the condition
## so we can use this to select only the values above 5
hh_members[hh_members > 5]
```


```{r, results='show', purl=FALSE}
hh_members[hh_members < 4 | hh_members > 7]
hh_members[hh_members >= 4 & hh_members <= 7]
```



```{r, results='show', purl=FALSE}
possessions <- c("car", "bicycle", "radio", "television", "mobile_phone")
possessions[possessions == "car" | possessions == "bicycle"] # returns both car and bicycle
```


```{r, results='show', purl=FALSE}
possessions %in% c("car", "bicycle")
```


```{r, results='show', purl=FALSE}
possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")
possessions[possessions %in% c("car", "bicycle", "motorcycle", "truck", "boat", "bus")]
```


```{r, purl=FALSE}
rooms <- c(2, 1, 1, NA, 7)
mean(rooms)
max(rooms)
mean(rooms, na.rm = TRUE)
max(rooms, na.rm = TRUE)
```



```{r, purl=FALSE}
## Extract those elements which are not missing values.
rooms[!is.na(rooms)]

## Count the number of missing values.
sum(is.na(rooms))

## Returns the object with incomplete cases removed. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
na.omit(rooms)

## Extract those elements which are complete cases. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
rooms[complete.cases(rooms)]
```
Recall that you can use the `typeof()` function to find the type of your atomic vector.

> ## Exercise
>
> 1. Using this vector of rooms, create a new vector with the NAs removed.
>
>     ```r
>     rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
>     ```
> 2. Use the function `median()` to calculate the median of the `rooms` vector.
>
> 3. Use R to figure out how many households in the set use more than 2 rooms for sleeping.
>
> > ## Solution
> > ```{r, answer=TRUE}
> > rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
> > rooms_no_na <- rooms[!is.na(rooms)]
> > # or
> > rooms_no_na <- na.omit(rooms)
> > # 2.
> > median(rooms, na.rm = TRUE)
> > # 3.
> > rooms_above_2 <- rooms_no_na[rooms_no_na > 2]
> > length(rooms_above_2)
> > ```
> {: .solution}
{: .challenge}


## noter og andet godt ##

Plottyper:

•	Strukturtegning
•	Kort
•	Diagram
•	Barplot
•	Scatterplot
o	Bobleplot
•	Linieplot
•	Boxplot
•	Violinplot
•	Heatmap
•	Dendrogramm

”Farlige” plots:
•	Lagkage
•	Wordcloud
•	Polygonpakning

Dernæst:
Hvad: 
Datatyper, antal, forhold, geografi, størrelser.
Men også - hvad katten vil du egentlig vise?
Og så vores skelnen mellem information og kunst.

Hvordan:
Position
Længder
Arealer
Vinkler
Retning/flow
Farver 
Geometriske former

Diagramtyper:
Do (til hvad)
Don't (hvorfor)

Afsluttende:
Eksempler på gode og dårlige visualiseringer.
Videre

Eksempler på gode og dårlige illustraioner:
Og hvorfor vi gør det!
Napoleons ruslandstogt (http://www.openculture.com/2019/07/napoleons-disastrous-invasion-of-russia-explained-in-an-1869-data-visualization.html)
Florence Nightingale: https://medium.com/nightingale/from-the-battlefield-to-basketball-a-data-visualization-journey-with-florence-nightingale-c39571686dfc
https://www.visualcapitalist.com/data-visualization-cholera/



{% include links.md %}
